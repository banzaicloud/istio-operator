{
  "openapi": "3.0.0",
  "info": {
    "title": "Istio Mesh descriptor",
    "version": "v1alpha1"
  },
  "components": {
    "schemas": {
      "istio.mesh.v1alpha1.AuthenticationPolicy": {
        "description": "AuthenticationPolicy defines how the proxy is authenticated when it connects to the control plane. It can be set for two different scopes, mesh-wide or set on a per-pod basis using the ProxyConfig annotation. Mesh policy cannot be INHERIT.",
        "type": "string",
        "enum": [
          "NONE",
          "MUTUAL_TLS",
          "INHERIT"
        ]
      },
      "istio.mesh.v1alpha1.Certificate": {
        "type": "object",
        "properties": {
          "secretName": {
            "description": "Name of the secret the certificate and its key will be stored into. If it is empty, it will not be stored into a secret. Instead, the certificate and its key will be stored into a hard-coded directory.",
            "type": "string"
          },
          "dnsNames": {
            "description": "The DNS names for the certificate. A certificate may contain multiple DNS names.",
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "istio.mesh.v1alpha1.ConfigSource": {
        "description": "ConfigSource describes information about a configuration store inside a mesh. A single control plane instance can interact with one or more data sources.",
        "type": "object",
        "properties": {
          "address": {
            "description": "Address of the server implementing the Istio Mesh Configuration protocol (MCP). Can be IP address or a fully qualified DNS name. Use xds:// to specify a grpc-based xds backend, k8s:// to specify a k8s controller or fs:/// to specify a file-based backend with absolute path to the directory.",
            "type": "string"
          },
          "tlsSettings": {
            "$ref": "#/components/schemas/istio.networking.v1alpha3.ClientTLSSettings"
          },
          "subscribedResources": {
            "description": "Describes the source of configuration, if nothing is specified default is MCP",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/istio.mesh.v1alpha1.Resource"
            }
          }
        }
      },
      "istio.mesh.v1alpha1.MeshConfig": {
        "description": "MeshConfig defines mesh-wide settings for the Istio service mesh.",
        "type": "object",
        "properties": {
          "localityLbSetting": {
            "$ref": "#/components/schemas/istio.networking.v1alpha3.LocalityLoadBalancerSetting"
          },
          "connectTimeout": {
            "description": "Connection timeout used by Envoy. (MUST BE \u003e=1ms) Default timeout is 10s.",
            "type": "string"
          },
          "tcpKeepalive": {
            "$ref": "#/components/schemas/istio.networking.v1alpha3.ConnectionPoolSettings.TCPSettings.TcpKeepalive"
          },
          "h2UpgradePolicy": {
            "$ref": "#/components/schemas/istio.mesh.v1alpha1.MeshConfig.H2UpgradePolicy"
          },
          "caCertificates": {
            "description": "The extra root certificates for workload-to-workload communication. The plugin certificates (the 'cacerts' secret) or self-signed certificates (the 'istio-ca-secret' secret) are automatically added by Istiod. The CA certificate that signs the workload certificates is automatically added by Istio Agent.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/istio.mesh.v1alpha1.MeshConfig.CertificateData"
            }
          },
          "proxyListenPort": {
            "description": "Port on which Envoy should listen for incoming connections from other services. Default port is 15001.",
            "type": "integer",
            "format": "int32"
          },
          "proxyHttpPort": {
            "description": "Port on which Envoy should listen for HTTP PROXY requests if set.",
            "type": "integer",
            "format": "int32"
          },
          "protocolDetectionTimeout": {
            "description": "Automatic protocol detection uses a set of heuristics to determine whether the connection is using TLS or not (on the server side), as well as the application protocol being used (e.g., http vs tcp). These heuristics rely on the client sending the first bits of data. For server first protocols like MySQL, MongoDB, etc. Envoy will timeout on the protocol detection after the specified period, defaulting to non mTLS plain TCP traffic. Set this field to tweak the period that Envoy will wait for the client to send the first bits of data. (MUST BE \u003e=1ms or 0s to disable). Default detection timeout is 0s (no timeout).",
            "type": "string"
          },
          "ingressClass": {
            "description": "Class of ingress resources to be processed by Istio ingress controller. This corresponds to the value of `kubernetes.io/ingress.class` annotation.",
            "type": "string"
          },
          "ingressService": {
            "description": "Name of the Kubernetes service used for the istio ingress controller. If no ingress controller is specified, the default value `istio-ingressgateway` is used.",
            "type": "string"
          },
          "ingressControllerMode": {
            "$ref": "#/components/schemas/istio.mesh.v1alpha1.MeshConfig.IngressControllerMode"
          },
          "ingressSelector": {
            "description": "Defines which gateway deployment to use as the Ingress controller. This field corresponds to the Gateway.selector field, and will be set as `istio: INGRESS_SELECTOR`. By default, `ingressgateway` is used, which will select the default IngressGateway as it has the `istio: ingressgateway` labels. It is recommended that this is the same value as ingress_service.",
            "type": "string"
          },
          "enableTracing": {
            "description": "Flag to control generation of trace spans and request IDs. Requires a trace span collector defined in the proxy configuration.",
            "type": "boolean"
          },
          "accessLogFile": {
            "description": "File address for the proxy access log (e.g. /dev/stdout). Empty value disables access logging.",
            "type": "string"
          },
          "accessLogFormat": {
            "description": "Format for the proxy access log Empty value results in proxy's default access log format",
            "type": "string"
          },
          "accessLogEncoding": {
            "$ref": "#/components/schemas/istio.mesh.v1alpha1.MeshConfig.AccessLogEncoding"
          },
          "enableEnvoyAccessLogService": {
            "description": "This flag enables Envoy's gRPC Access Log Service. See [Access Log Service](https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/access_loggers/grpc/v3/als.proto) for details about Envoy's gRPC Access Log Service API. Default value is `false`.",
            "type": "boolean"
          },
          "disableEnvoyListenerLog": {
            "description": "This flag disables Envoy Listener logs. See [Listener Access Log](https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/listener/v3/listener.proto#envoy-v3-api-field-config-listener-v3-listener-access-log) Istio Enables Envoy's listener access logs on \"NoRoute\" response flag. Default value is `false`.",
            "type": "boolean"
          },
          "defaultConfig": {
            "$ref": "#/components/schemas/istio.mesh.v1alpha1.ProxyConfig"
          },
          "outboundTrafficPolicy": {
            "$ref": "#/components/schemas/istio.mesh.v1alpha1.MeshConfig.OutboundTrafficPolicy"
          },
          "configSources": {
            "description": "ConfigSource describes a source of configuration data for networking rules, and other Istio configuration artifacts. Multiple data sources can be configured for a single control plane.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/istio.mesh.v1alpha1.ConfigSource"
            }
          },
          "enableAutoMtls": {
            "description": "This flag is used to enable mutual `TLS` automatically for service to service communication within the mesh, default true. If set to true, and a given service does not have a corresponding `DestinationRule` configured, or its `DestinationRule` does not have ClientTLSSettings specified, Istio configures client side TLS configuration appropriately. More specifically, If the upstream authentication policy is in `STRICT` mode, use Istio provisioned certificate for mutual `TLS` to connect to upstream. If upstream service is in plain text mode, use plain text. If the upstream authentication policy is in PERMISSIVE mode, Istio configures clients to use mutual `TLS` when server sides are capable of accepting mutual `TLS` traffic. If service `DestinationRule` exists and has `ClientTLSSettings` specified, that is always used instead.",
            "type": "boolean",
            "nullable": true
          },
          "trustDomain": {
            "description": "The trust domain corresponds to the trust root of a system. Refer to [SPIFFE-ID](https://github.com/spiffe/spiffe/blob/master/standards/SPIFFE-ID.md#21-trust-domain)",
            "type": "string"
          },
          "trustDomainAliases": {
            "description": "The trust domain aliases represent the aliases of `trust_domain`. For example, if we have ```yaml trustDomain: td1 trustDomainAliases: [\"td2\", \"td3\"] ``` Any service with the identity `td1/ns/foo/sa/a-service-account`, `td2/ns/foo/sa/a-service-account`, or `td3/ns/foo/sa/a-service-account` will be treated the same in the Istio mesh.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "defaultServiceExportTo": {
            "description": "The default value for the ServiceEntry.export_to field and services imported through container registry integrations, e.g. this applies to Kubernetes Service resources. The value is a list of namespace names and reserved namespace aliases. The allowed namespace aliases are: ``` * - All Namespaces . - Current Namespace ~ - No Namespace ``` If not set the system will use \"*\" as the default value which implies that services are exported to all namespaces. `All namespaces` is a reasonable default for implementations that don't need to restrict access or visibility of services across namespace boundaries. If that requirement is present it is generally good practice to make the default `Current namespace` so that services are only visible within their own namespaces by default. Operators can then expand the visibility of services to other namespaces as needed. Use of `No Namespace` is expected to be rare but can have utility for deployments where dependency management needs to be precise even within the scope of a single namespace. For further discussion see the reference documentation for `ServiceEntry`, `Sidecar`, and `Gateway`.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "defaultVirtualServiceExportTo": {
            "description": "The default value for the VirtualService.export_to field. Has the same syntax as `default_service_export_to`. If not set the system will use \"*\" as the default value which implies that virtual services are exported to all namespaces",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "defaultDestinationRuleExportTo": {
            "description": "The default value for the `DestinationRule.export_to` field. Has the same syntax as `default_service_export_to`. If not set the system will use \"*\" as the default value which implies that destination rules are exported to all namespaces",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "rootNamespace": {
            "description": "The namespace to treat as the administrative root namespace for Istio configuration. When processing a leaf namespace Istio will search for declarations in that namespace first and if none are found it will search in the root namespace. Any matching declaration found in the root namespace is processed as if it were declared in the leaf namespace. The precise semantics of this processing are documented on each resource type.",
            "type": "string"
          },
          "dnsRefreshRate": {
            "description": "Configures DNS refresh rate for Envoy clusters of type `STRICT_DNS` Default refresh rate is `5s`.",
            "type": "string"
          },
          "inboundClusterStatName": {
            "description": "Name to be used while emitting statistics for inbound clusters. The same pattern is used while computing stat prefix for network filters like TCP and Redis. By default, Istio emits statistics with the pattern `inbound|\u003cport\u003e|\u003cport-name\u003e|\u003cservice-FQDN\u003e`. For example `inbound|7443|grpc-reviews|reviews.prod.svc.cluster.local`. This can be used to override that pattern. A Pattern can be composed of various pre-defined variables. The following variables are supported. - `%SERVICE%` - Will be substituted with name of the service. - `%SERVICE_FQDN%` - Will be substituted with FQDN of the service. - `%SERVICE_PORT%` - Will be substituted with port of the service. - `%SERVICE_PORT_NAME%` - Will be substituted with port name of the service. Following are some examples of supported patterns for reviews: - `%SERVICE_FQDN%_%SERVICE_PORT%` will use reviews.prod.svc.cluster.local_7443 as the stats name. - `%SERVICE%` will use reviews.prod as the stats name.",
            "type": "string"
          },
          "outboundClusterStatName": {
            "description": "Name to be used while emitting statistics for outbound clusters. The same pattern is used while computing stat prefix for network filters like TCP and Redis. By default, Istio emits statistics with the pattern `outbound|\u003cport\u003e|\u003csubsetname\u003e|\u003cservice-FQDN\u003e`. For example `outbound|8080|v2|reviews.prod.svc.cluster.local`. This can be used to override that pattern. A Pattern can be composed of various pre-defined variables. The following variables are supported. - `%SERVICE%` - Will be substituted with name of the service. - `%SERVICE_FQDN%` - Will be substituted with FQDN of the service. - `%SERVICE_PORT%` - Will be substituted with port of the service. - `%SERVICE_PORT_NAME%` - Will be substituted with port name of the service. - `%SUBSET_NAME%` - Will be substituted with subset. Following are some examples of supported patterns for reviews: - `%SERVICE_FQDN%_%SERVICE_PORT%` will use `reviews.prod.svc.cluster.local_7443` as the stats name. - `%SERVICE%` will use reviews.prod as the stats name.",
            "type": "string"
          },
          "certificates": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/istio.mesh.v1alpha1.Certificate"
            }
          },
          "serviceSettings": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/istio.mesh.v1alpha1.MeshConfig.ServiceSettings"
            }
          },
          "enablePrometheusMerge": {
            "description": "If enabled, Istio agent will merge metrics exposed by the application with metrics from Envoy and Istio agent. The sidecar injection will replace `prometheus.io` annotations present on the pod and redirect them towards Istio agent, which will then merge metrics of from the application with Istio metrics. This relies on the annotations `prometheus.io/scrape`, `prometheus.io/port`, and `prometheus.io/path` annotations. If you are running a separately managed Envoy with an Istio sidecar, this may cause issues, as the metrics will collide. In this case, it is recommended to disable aggregation on that deployment with the `prometheus.istio.io/merge-metrics: \"false\"` annotation. If not specified, this will be enabled by default.",
            "type": "boolean",
            "nullable": true
          },
          "verifyCertificateAtClient": {
            "type": "boolean",
            "deprecated": true,
            "nullable": true
          },
          "ca": {
            "$ref": "#/components/schemas/istio.mesh.v1alpha1.MeshConfig.CA"
          },
          "extensionProviders": {
            "description": "Defines a list of extension providers that extend Istio's functionality. For example, the AuthorizationPolicy can be used with an extension provider to delegate the authorization decision to a custom authorization system.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/istio.mesh.v1alpha1.MeshConfig.ExtensionProvider"
            }
          },
          "defaultProviders": {
            "$ref": "#/components/schemas/istio.mesh.v1alpha1.MeshConfig.DefaultProviders"
          },
          "discoverySelectors": {
            "description": "A list of Kubernetes selectors that specify the set of namespaces that Istio considers when computing configuration updates for sidecars. This can be used to reduce Istio's computational load by limiting the number of entities (including services, pods, and endpoints) that are watched and processed. If omitted, Istio will use the default behavior of processing all namespaces in the cluster. Elements in the list are disjunctive (OR semantics), i.e. a namespace will be included if it matches any selector. The following example selects any namespace that matches either below: 1. The namespace has both of these labels: `env: prod` and `region: us-east1` 2. The namespace has label `app` equal to `cassandra` or `spark`. ```yaml discoverySelectors: - matchLabels: env: prod region: us-east1 - matchExpressions: - key: app operator: In values: - cassandra - spark ``` Refer to the [kubernetes selector docs](https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors) for additional detail on selector semantics.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector"
            }
          },
          "pathNormalization": {
            "$ref": "#/components/schemas/istio.mesh.v1alpha1.MeshConfig.ProxyPathNormalization"
          },
          "defaultHttpRetryPolicy": {
            "$ref": "#/components/schemas/istio.networking.v1alpha3.HTTPRetry"
          },
          "meshMTLS": {
            "$ref": "#/components/schemas/istio.mesh.v1alpha1.MeshConfig.TLSConfig"
          }
        }
      },
      "istio.mesh.v1alpha1.MeshConfig.AccessLogEncoding": {
        "type": "string",
        "enum": [
          "TEXT",
          "JSON"
        ]
      },
      "istio.mesh.v1alpha1.MeshConfig.CA": {
        "type": "object",
        "properties": {
          "address": {
            "description": "REQUIRED. Address of the CA server implementing the Istio CA gRPC API. Can be IP address or a fully qualified DNS name with port Eg: custom-ca.default.svc.cluster.local:8932, 192.168.23.2:9000",
            "type": "string"
          },
          "tlsSettings": {
            "$ref": "#/components/schemas/istio.networking.v1alpha3.ClientTLSSettings"
          },
          "requestTimeout": {
            "description": "timeout for forward CSR requests from Istiod to External CA Default: 10s",
            "type": "string"
          },
          "istiodSide": {
            "description": "Use istiod_side to specify CA Server integrate to Istiod side or Agent side Default: true",
            "type": "boolean"
          }
        }
      },
      "istio.mesh.v1alpha1.MeshConfig.CertificateData": {
        "type": "object",
        "properties": {
          "certSigners": {
            "description": "Optional. Specify the kubernetes signers (External CA) that use this trustAnchor when Istiod is acting as RA(registration authority) If set, they are used for these signers. Otherwise, this trustAnchor is used for all signers.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "trustDomains": {
            "description": "Optional. Specify the list of trust domains to which this trustAnchor data belongs. If set, they are used for these trust domains. Otherwise, this trustAnchor is used for default trust domain and its aliases. Note that we can have multiple trustAnchor data for a same trust_domain. In that case, trustAnchors with a same trust domain will be merged and used together to verify peer certificates. If neither cert_signers nor trust_domains is set, this trustAnchor is used for all trust domains and all signers. If only trust_domains is set, this trustAnchor is used for these trust_domains and all signers. If only cert_signers is set, this trustAnchor is used for these cert_signers and all trust domains. If both cert_signers and trust_domains is set, this trustAnchor is only used for these signers and trust domains.",
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "oneOf": [
          {
            "not": {
              "anyOf": [
                {
                  "required": [
                    "pem"
                  ],
                  "properties": {
                    "pem": {
                      "description": "The PEM data of the certificate.",
                      "type": "string"
                    }
                  }
                },
                {
                  "required": [
                    "spiffeBundleUrl"
                  ],
                  "properties": {
                    "spiffeBundleUrl": {
                      "description": "The SPIFFE bundle endpoint URL that complies to: https://github.com/spiffe/spiffe/blob/master/standards/SPIFFE_Trust_Domain_and_Bundle.md#the-spiffe-trust-domain-and-bundle The endpoint should support authentication based on Web PKI: https://github.com/spiffe/spiffe/blob/master/standards/SPIFFE_Trust_Domain_and_Bundle.md#521-web-pki The certificate is retrieved from the endpoint.",
                      "type": "string"
                    }
                  }
                }
              ]
            }
          },
          {
            "required": [
              "pem"
            ],
            "properties": {
              "pem": {
                "description": "The PEM data of the certificate.",
                "type": "string"
              }
            }
          },
          {
            "required": [
              "spiffeBundleUrl"
            ],
            "properties": {
              "spiffeBundleUrl": {
                "description": "The SPIFFE bundle endpoint URL that complies to: https://github.com/spiffe/spiffe/blob/master/standards/SPIFFE_Trust_Domain_and_Bundle.md#the-spiffe-trust-domain-and-bundle The endpoint should support authentication based on Web PKI: https://github.com/spiffe/spiffe/blob/master/standards/SPIFFE_Trust_Domain_and_Bundle.md#521-web-pki The certificate is retrieved from the endpoint.",
                "type": "string"
              }
            }
          }
        ]
      },
      "istio.mesh.v1alpha1.MeshConfig.DefaultProviders": {
        "description": "Holds the name references to the providers that will be used by default in other Istio configuration resources if the provider is not specified. These names must match a provider defined in `extension_providers` that is one of the supported tracing providers.",
        "type": "object",
        "properties": {
          "tracing": {
            "description": "Name of the default provider(s) for tracing.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "metrics": {
            "description": "Name of the default provider(s) for metrics.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "accessLogging": {
            "description": "Name of the default provider(s) for access logging.",
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "istio.mesh.v1alpha1.MeshConfig.ExtensionProvider": {
        "type": "object",
        "properties": {
          "name": {
            "description": "REQUIRED. A unique name identifying the extension provider.",
            "type": "string"
          }
        },
        "oneOf": [
          {
            "not": {
              "anyOf": [
                {
                  "required": [
                    "envoyExtAuthzHttp"
                  ],
                  "properties": {
                    "envoyExtAuthzHttp": {
                      "$ref": "#/components/schemas/istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.EnvoyExternalAuthorizationHttpProvider"
                    }
                  }
                },
                {
                  "required": [
                    "envoyExtAuthzGrpc"
                  ],
                  "properties": {
                    "envoyExtAuthzGrpc": {
                      "$ref": "#/components/schemas/istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.EnvoyExternalAuthorizationGrpcProvider"
                    }
                  }
                },
                {
                  "required": [
                    "zipkin"
                  ],
                  "properties": {
                    "zipkin": {
                      "$ref": "#/components/schemas/istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.ZipkinTracingProvider"
                    }
                  }
                },
                {
                  "required": [
                    "lightstep"
                  ],
                  "properties": {
                    "lightstep": {
                      "$ref": "#/components/schemas/istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.LightstepTracingProvider",
                      "deprecated": true
                    }
                  }
                },
                {
                  "required": [
                    "datadog"
                  ],
                  "properties": {
                    "datadog": {
                      "$ref": "#/components/schemas/istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.DatadogTracingProvider"
                    }
                  }
                },
                {
                  "required": [
                    "stackdriver"
                  ],
                  "properties": {
                    "stackdriver": {
                      "$ref": "#/components/schemas/istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.StackdriverProvider"
                    }
                  }
                },
                {
                  "required": [
                    "opencensus"
                  ],
                  "properties": {
                    "opencensus": {
                      "$ref": "#/components/schemas/istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.OpenCensusAgentTracingProvider"
                    }
                  }
                },
                {
                  "required": [
                    "skywalking"
                  ],
                  "properties": {
                    "skywalking": {
                      "$ref": "#/components/schemas/istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.SkyWalkingTracingProvider"
                    }
                  }
                },
                {
                  "required": [
                    "opentelemetry"
                  ],
                  "properties": {
                    "opentelemetry": {
                      "$ref": "#/components/schemas/istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.OpenTelemetryTracingProvider"
                    }
                  }
                },
                {
                  "required": [
                    "prometheus"
                  ],
                  "properties": {
                    "prometheus": {
                      "$ref": "#/components/schemas/istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.PrometheusMetricsProvider"
                    }
                  }
                },
                {
                  "required": [
                    "envoyFileAccessLog"
                  ],
                  "properties": {
                    "envoyFileAccessLog": {
                      "$ref": "#/components/schemas/istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.EnvoyFileAccessLogProvider"
                    }
                  }
                },
                {
                  "required": [
                    "envoyHttpAls"
                  ],
                  "properties": {
                    "envoyHttpAls": {
                      "$ref": "#/components/schemas/istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.EnvoyHttpGrpcV3LogProvider"
                    }
                  }
                },
                {
                  "required": [
                    "envoyTcpAls"
                  ],
                  "properties": {
                    "envoyTcpAls": {
                      "$ref": "#/components/schemas/istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.EnvoyTcpGrpcV3LogProvider"
                    }
                  }
                },
                {
                  "required": [
                    "envoyOtelAls"
                  ],
                  "properties": {
                    "envoyOtelAls": {
                      "$ref": "#/components/schemas/istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.EnvoyOpenTelemetryLogProvider"
                    }
                  }
                },
                {}
              ]
            }
          },
          {
            "required": [
              "envoyExtAuthzHttp"
            ],
            "properties": {
              "envoyExtAuthzHttp": {
                "$ref": "#/components/schemas/istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.EnvoyExternalAuthorizationHttpProvider"
              }
            }
          },
          {
            "required": [
              "envoyExtAuthzGrpc"
            ],
            "properties": {
              "envoyExtAuthzGrpc": {
                "$ref": "#/components/schemas/istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.EnvoyExternalAuthorizationGrpcProvider"
              }
            }
          },
          {
            "required": [
              "zipkin"
            ],
            "properties": {
              "zipkin": {
                "$ref": "#/components/schemas/istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.ZipkinTracingProvider"
              }
            }
          },
          {
            "required": [
              "lightstep"
            ],
            "properties": {
              "lightstep": {
                "$ref": "#/components/schemas/istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.LightstepTracingProvider",
                "deprecated": true
              }
            }
          },
          {
            "required": [
              "datadog"
            ],
            "properties": {
              "datadog": {
                "$ref": "#/components/schemas/istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.DatadogTracingProvider"
              }
            }
          },
          {
            "required": [
              "stackdriver"
            ],
            "properties": {
              "stackdriver": {
                "$ref": "#/components/schemas/istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.StackdriverProvider"
              }
            }
          },
          {
            "required": [
              "opencensus"
            ],
            "properties": {
              "opencensus": {
                "$ref": "#/components/schemas/istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.OpenCensusAgentTracingProvider"
              }
            }
          },
          {
            "required": [
              "skywalking"
            ],
            "properties": {
              "skywalking": {
                "$ref": "#/components/schemas/istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.SkyWalkingTracingProvider"
              }
            }
          },
          {
            "required": [
              "opentelemetry"
            ],
            "properties": {
              "opentelemetry": {
                "$ref": "#/components/schemas/istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.OpenTelemetryTracingProvider"
              }
            }
          },
          {
            "required": [
              "prometheus"
            ],
            "properties": {
              "prometheus": {
                "$ref": "#/components/schemas/istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.PrometheusMetricsProvider"
              }
            }
          },
          {
            "required": [
              "envoyFileAccessLog"
            ],
            "properties": {
              "envoyFileAccessLog": {
                "$ref": "#/components/schemas/istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.EnvoyFileAccessLogProvider"
              }
            }
          },
          {
            "required": [
              "envoyHttpAls"
            ],
            "properties": {
              "envoyHttpAls": {
                "$ref": "#/components/schemas/istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.EnvoyHttpGrpcV3LogProvider"
              }
            }
          },
          {
            "required": [
              "envoyTcpAls"
            ],
            "properties": {
              "envoyTcpAls": {
                "$ref": "#/components/schemas/istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.EnvoyTcpGrpcV3LogProvider"
              }
            }
          },
          {
            "required": [
              "envoyOtelAls"
            ],
            "properties": {
              "envoyOtelAls": {
                "$ref": "#/components/schemas/istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.EnvoyOpenTelemetryLogProvider"
              }
            }
          },
          {
            "not": {
              "anyOf": [
                {},
                {
                  "required": [
                    "envoyExtAuthzHttp"
                  ],
                  "properties": {
                    "envoyExtAuthzHttp": {
                      "$ref": "#/components/schemas/istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.EnvoyExternalAuthorizationHttpProvider"
                    }
                  }
                },
                {
                  "required": [
                    "envoyExtAuthzGrpc"
                  ],
                  "properties": {
                    "envoyExtAuthzGrpc": {
                      "$ref": "#/components/schemas/istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.EnvoyExternalAuthorizationGrpcProvider"
                    }
                  }
                },
                {
                  "required": [
                    "zipkin"
                  ],
                  "properties": {
                    "zipkin": {
                      "$ref": "#/components/schemas/istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.ZipkinTracingProvider"
                    }
                  }
                },
                {
                  "required": [
                    "lightstep"
                  ],
                  "properties": {
                    "lightstep": {
                      "$ref": "#/components/schemas/istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.LightstepTracingProvider",
                      "deprecated": true
                    }
                  }
                },
                {
                  "required": [
                    "datadog"
                  ],
                  "properties": {
                    "datadog": {
                      "$ref": "#/components/schemas/istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.DatadogTracingProvider"
                    }
                  }
                },
                {
                  "required": [
                    "stackdriver"
                  ],
                  "properties": {
                    "stackdriver": {
                      "$ref": "#/components/schemas/istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.StackdriverProvider"
                    }
                  }
                },
                {
                  "required": [
                    "opencensus"
                  ],
                  "properties": {
                    "opencensus": {
                      "$ref": "#/components/schemas/istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.OpenCensusAgentTracingProvider"
                    }
                  }
                },
                {
                  "required": [
                    "skywalking"
                  ],
                  "properties": {
                    "skywalking": {
                      "$ref": "#/components/schemas/istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.SkyWalkingTracingProvider"
                    }
                  }
                },
                {
                  "required": [
                    "opentelemetry"
                  ],
                  "properties": {
                    "opentelemetry": {
                      "$ref": "#/components/schemas/istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.OpenTelemetryTracingProvider"
                    }
                  }
                },
                {
                  "required": [
                    "prometheus"
                  ],
                  "properties": {
                    "prometheus": {
                      "$ref": "#/components/schemas/istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.PrometheusMetricsProvider"
                    }
                  }
                },
                {
                  "required": [
                    "envoyFileAccessLog"
                  ],
                  "properties": {
                    "envoyFileAccessLog": {
                      "$ref": "#/components/schemas/istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.EnvoyFileAccessLogProvider"
                    }
                  }
                },
                {
                  "required": [
                    "envoyHttpAls"
                  ],
                  "properties": {
                    "envoyHttpAls": {
                      "$ref": "#/components/schemas/istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.EnvoyHttpGrpcV3LogProvider"
                    }
                  }
                },
                {
                  "required": [
                    "envoyTcpAls"
                  ],
                  "properties": {
                    "envoyTcpAls": {
                      "$ref": "#/components/schemas/istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.EnvoyTcpGrpcV3LogProvider"
                    }
                  }
                },
                {
                  "required": [
                    "envoyOtelAls"
                  ],
                  "properties": {
                    "envoyOtelAls": {
                      "$ref": "#/components/schemas/istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.EnvoyOpenTelemetryLogProvider"
                    }
                  }
                }
              ]
            }
          }
        ]
      },
      "istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.DatadogTracingProvider": {
        "$ref": "#/components/schemas/istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.DatadogTracingProvider"
      },
      "istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.EnvoyExternalAuthorizationGrpcProvider": {
        "$ref": "#/components/schemas/istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.EnvoyExternalAuthorizationGrpcProvider"
      },
      "istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.EnvoyExternalAuthorizationHttpProvider": {
        "$ref": "#/components/schemas/istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.EnvoyExternalAuthorizationHttpProvider"
      },
      "istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.EnvoyFileAccessLogProvider": {
        "$ref": "#/components/schemas/istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.EnvoyFileAccessLogProvider"
      },
      "istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.EnvoyHttpGrpcV3LogProvider": {
        "$ref": "#/components/schemas/istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.EnvoyHttpGrpcV3LogProvider"
      },
      "istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.EnvoyOpenTelemetryLogProvider": {
        "$ref": "#/components/schemas/istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.EnvoyOpenTelemetryLogProvider"
      },
      "istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.EnvoyTcpGrpcV3LogProvider": {
        "$ref": "#/components/schemas/istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.EnvoyTcpGrpcV3LogProvider"
      },
      "istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.LightstepTracingProvider": {
        "$ref": "#/components/schemas/istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.LightstepTracingProvider",
        "deprecated": true
      },
      "istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.OpenCensusAgentTracingProvider": {
        "$ref": "#/components/schemas/istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.OpenCensusAgentTracingProvider"
      },
      "istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.OpenTelemetryTracingProvider": {
        "$ref": "#/components/schemas/istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.OpenTelemetryTracingProvider"
      },
      "istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.PrometheusMetricsProvider": {
        "$ref": "#/components/schemas/istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.PrometheusMetricsProvider"
      },
      "istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.SkyWalkingTracingProvider": {
        "$ref": "#/components/schemas/istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.SkyWalkingTracingProvider"
      },
      "istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.StackdriverProvider": {
        "$ref": "#/components/schemas/istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.StackdriverProvider"
      },
      "istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.ZipkinTracingProvider": {
        "$ref": "#/components/schemas/istio.mesh.v1alpha1.MeshConfig.ExtensionProvider.ZipkinTracingProvider"
      },
      "istio.mesh.v1alpha1.MeshConfig.H2UpgradePolicy": {
        "description": "Default Policy for upgrading http1.1 connections to http2.",
        "type": "string",
        "enum": [
          "DO_NOT_UPGRADE",
          "UPGRADE"
        ]
      },
      "istio.mesh.v1alpha1.MeshConfig.IngressControllerMode": {
        "type": "string",
        "enum": [
          "UNSPECIFIED",
          "OFF",
          "DEFAULT",
          "STRICT"
        ]
      },
      "istio.mesh.v1alpha1.MeshConfig.OutboundTrafficPolicy": {
        "type": "object",
        "properties": {
          "mode": {
            "$ref": "#/components/schemas/istio.mesh.v1alpha1.MeshConfig.OutboundTrafficPolicy.Mode"
          }
        }
      },
      "istio.mesh.v1alpha1.MeshConfig.OutboundTrafficPolicy.Mode": {
        "type": "string",
        "enum": [
          "REGISTRY_ONLY",
          "ALLOW_ANY"
        ]
      },
      "istio.mesh.v1alpha1.MeshConfig.ProxyPathNormalization": {
        "type": "object",
        "properties": {
          "normalization": {
            "$ref": "#/components/schemas/istio.mesh.v1alpha1.MeshConfig.ProxyPathNormalization.NormalizationType"
          }
        }
      },
      "istio.mesh.v1alpha1.MeshConfig.ProxyPathNormalization.NormalizationType": {
        "type": "string",
        "enum": [
          "DEFAULT",
          "NONE",
          "BASE",
          "MERGE_SLASHES",
          "DECODE_AND_MERGE_SLASHES"
        ]
      },
      "istio.mesh.v1alpha1.MeshConfig.ServiceSettings": {
        "type": "object",
        "properties": {
          "hosts": {
            "description": "The services to which the Settings should be applied. Services are selected using the hostname matching rules used by DestinationRule. For example: foo.bar.svc.cluster.local, *.baz.svc.cluster.local",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "settings": {
            "$ref": "#/components/schemas/istio.mesh.v1alpha1.MeshConfig.ServiceSettings.Settings"
          }
        }
      },
      "istio.mesh.v1alpha1.MeshConfig.ServiceSettings.Settings": {
        "description": "Settings for the selected services.",
        "type": "object",
        "properties": {
          "clusterLocal": {
            "description": "If true, specifies that the client and service endpoints must reside in the same cluster. By default, in multi-cluster deployments, the Istio control plane assumes all service endpoints to be reachable from any client in any of the clusters which are part of the mesh. This configuration option limits the set of service endpoints visible to a client to be cluster scoped. There are some common scenarios when this can be useful: - A service (or group of services) is inherently local to the cluster and has local storage for that cluster. For example, the kube-system namespace (e.g. the Kube API Server). - A mesh administrator wants to slowly migrate services to Istio. They might start by first having services cluster-local and then slowly transition them to mesh-wide. They could do this service-by-service (e.g. mysvc.myns.svc.cluster.local) or as a group (e.g. *.myns.svc.cluster.local). By default Istio will consider kubernetes.default.svc (i.e. the API Server) as well as all services in the kube-system namespace to be cluster-local, unless explicitly overridden here.",
            "type": "boolean"
          }
        }
      },
      "istio.mesh.v1alpha1.MeshConfig.TLSConfig": {
        "type": "object",
        "properties": {
          "minProtocolVersion": {
            "$ref": "#/components/schemas/istio.mesh.v1alpha1.MeshConfig.TLSConfig.TLSProtocol"
          }
        }
      },
      "istio.mesh.v1alpha1.MeshConfig.TLSConfig.TLSProtocol": {
        "description": "TLS protocol versions.",
        "type": "string",
        "enum": [
          "TLS_AUTO",
          "TLSV1_2",
          "TLSV1_3"
        ]
      },
      "istio.mesh.v1alpha1.PrivateKeyProvider": {
        "description": "PrivateKeyProvider defines private key configuration for gateways and sidecars. This can be configured mesh wide or individual per-workload basis.",
        "type": "object",
        "oneOf": [
          {
            "not": {
              "anyOf": [
                {
                  "required": [
                    "cryptomb"
                  ],
                  "properties": {
                    "cryptomb": {
                      "$ref": "#/components/schemas/istio.mesh.v1alpha1.PrivateKeyProvider.CryptoMb"
                    }
                  }
                },
                {
                  "required": [
                    "qat"
                  ],
                  "properties": {
                    "qat": {
                      "$ref": "#/components/schemas/istio.mesh.v1alpha1.PrivateKeyProvider.QAT"
                    }
                  }
                }
              ]
            }
          },
          {
            "required": [
              "cryptomb"
            ],
            "properties": {
              "cryptomb": {
                "$ref": "#/components/schemas/istio.mesh.v1alpha1.PrivateKeyProvider.CryptoMb"
              }
            }
          },
          {
            "required": [
              "qat"
            ],
            "properties": {
              "qat": {
                "$ref": "#/components/schemas/istio.mesh.v1alpha1.PrivateKeyProvider.QAT"
              }
            }
          }
        ]
      },
      "istio.mesh.v1alpha1.PrivateKeyProvider.CryptoMb": {
        "$ref": "#/components/schemas/istio.mesh.v1alpha1.PrivateKeyProvider.CryptoMb"
      },
      "istio.mesh.v1alpha1.PrivateKeyProvider.QAT": {
        "$ref": "#/components/schemas/istio.mesh.v1alpha1.PrivateKeyProvider.QAT"
      },
      "istio.mesh.v1alpha1.ProxyConfig": {
        "description": "ProxyConfig defines variables for individual Envoy instances. This can be configured on a per-workload basis as well as by the mesh-wide defaults. To set the mesh wide defaults, configure the `defaultConfig` section of `meshConfig`. For example: ``` meshConfig: defaultConfig: discoveryAddress: istiod:15012 ``` This can also be configured on a per-workload basis by configuring the `proxy.istio.io/config` annotation on the pod. For example: ``` annotations: proxy.istio.io/config: | discoveryAddress: istiod:15012 ``` If both are configured, the two are merged with per field semantics; the field set in annotation will fully replace the field from mesh config defaults. This is different than a deep merge provided by protobuf. For example, `\"tracing\": { \"sampling\": 5 }` would completely override a setting configuring a tracing provider such as `\"tracing\": { \"zipkin\": { \"address\": \"...\" } }`. Note: fields in ProxyConfig are not dynamically configured; changes will require restart of workloads to take effect.",
        "type": "object",
        "properties": {
          "image": {
            "$ref": "#/components/schemas/istio.networking.v1beta1.ProxyImage"
          },
          "readinessProbe": {
            "$ref": "#/components/schemas/istio.networking.v1alpha3.ReadinessProbe"
          },
          "tracing": {
            "$ref": "#/components/schemas/istio.mesh.v1alpha1.Tracing"
          },
          "concurrency": {
            "description": "The number of worker threads to run. If unset, this will be automatically determined based on CPU requests/limits. If set to 0, all cores on the machine will be used. Default is 2 worker threads.",
            "type": "integer",
            "nullable": true
          },
          "configPath": {
            "description": "Path to the generated configuration file directory. Proxy agent generates the actual configuration and stores it in this directory.",
            "type": "string"
          },
          "binaryPath": {
            "description": "Path to the proxy binary",
            "type": "string"
          },
          "drainDuration": {
            "description": "The time in seconds that Envoy will drain connections during a hot restart. MUST be \u003e=1s (e.g., _1s/1m/1h_) Default drain duration is `45s`.",
            "type": "string"
          },
          "discoveryAddress": {
            "description": "Address of the discovery service exposing xDS with mTLS connection. The inject configuration may override this value.",
            "type": "string"
          },
          "discoveryRefreshDelay": {
            "type": "string",
            "deprecated": true
          },
          "zipkinAddress": {
            "description": "Address of the Zipkin service (e.g. _zipkin:9411_). DEPRECATED: Use [tracing][istio.mesh.v1alpha1.ProxyConfig.tracing] instead.",
            "type": "string",
            "deprecated": true
          },
          "statsdUdpAddress": {
            "description": "IP Address and Port of a statsd UDP listener (e.g. `10.75.241.127:9125`).",
            "type": "string"
          },
          "envoyMetricsServiceAddress": {
            "type": "string",
            "deprecated": true
          },
          "proxyAdminPort": {
            "description": "Port on which Envoy should listen for administrative commands. Default port is `15000`.",
            "type": "integer",
            "format": "int32"
          },
          "availabilityZone": {
            "type": "string",
            "deprecated": true
          },
          "controlPlaneAuthPolicy": {
            "$ref": "#/components/schemas/istio.mesh.v1alpha1.AuthenticationPolicy"
          },
          "customConfigFile": {
            "description": "File path of custom proxy configuration, currently used by proxies in front of Mixer and Pilot.",
            "type": "string"
          },
          "statNameLength": {
            "description": "Maximum length of name field in Envoy's metrics. The length of the name field is determined by the length of a name field in a service and the set of labels that comprise a particular version of the service. The default value is set to 189 characters. Envoy's internal metrics take up 67 characters, for a total of 256 character name per metric. Increase the value of this field if you find that the metrics from Envoys are truncated.",
            "type": "integer",
            "format": "int32"
          },
          "proxyBootstrapTemplatePath": {
            "description": "Path to the proxy bootstrap template file",
            "type": "string"
          },
          "interceptionMode": {
            "$ref": "#/components/schemas/istio.mesh.v1alpha1.ProxyConfig.InboundInterceptionMode"
          },
          "sds": {
            "$ref": "#/components/schemas/istio.mesh.v1alpha1.SDS",
            "deprecated": true
          },
          "envoyAccessLogService": {
            "$ref": "#/components/schemas/istio.mesh.v1alpha1.RemoteService"
          },
          "envoyMetricsService": {
            "$ref": "#/components/schemas/istio.mesh.v1alpha1.RemoteService"
          },
          "proxyMetadata": {
            "description": "Additional environment variables for the proxy. Names starting with `ISTIO_META_` will be included in the generated bootstrap and sent to the XDS server.",
            "type": "object",
            "additionalProperties": {
              "type": "string"
            }
          },
          "runtimeValues": {
            "description": "Envoy [runtime configuration](https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/operations/runtime) to set during bootstrapping. This enables setting experimental, unsafe, unsupported, and deprecated features that should be used with extreme caution.",
            "type": "object",
            "additionalProperties": {
              "type": "string"
            }
          },
          "statusPort": {
            "description": "Port on which the agent should listen for administrative commands such as readiness probe. Default is set to port `15020`.",
            "type": "integer",
            "format": "int32"
          },
          "extraStatTags": {
            "description": "An additional list of tags to extract from the in-proxy Istio telemetry. These extra tags can be added by configuring the telemetry extension. Each additional tag needs to be present in this list. Extra tags emitted by the telemetry extensions must be listed here so that they can be processed and exposed as Prometheus metrics.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "gatewayTopology": {
            "$ref": "#/components/schemas/istio.mesh.v1alpha1.Topology"
          },
          "terminationDrainDuration": {
            "description": "The amount of time allowed for connections to complete on proxy shutdown. On receiving `SIGTERM` or `SIGINT`, `istio-agent` tells the active Envoy to start draining, preventing any new connections and allowing existing connections to complete. It then sleeps for the `termination_drain_duration` and then kills any remaining active Envoy processes. If not set, a default of `5s` will be applied.",
            "type": "string"
          },
          "meshId": {
            "description": "The unique identifier for the [service mesh](https://istio.io/docs/reference/glossary/#service-mesh) All control planes running in the same service mesh should specify the same mesh ID. Mesh ID is used to label telemetry reports for cases where telemetry from multiple meshes is mixed together.",
            "type": "string"
          },
          "proxyStatsMatcher": {
            "$ref": "#/components/schemas/istio.mesh.v1alpha1.ProxyConfig.ProxyStatsMatcher"
          },
          "holdApplicationUntilProxyStarts": {
            "description": "Boolean flag for enabling/disabling the holdApplicationUntilProxyStarts behavior. This feature adds hooks to delay application startup until the pod proxy is ready to accept traffic, mitigating some startup race conditions. Default value is 'false'.",
            "type": "boolean",
            "nullable": true
          },
          "caCertificatesPem": {
            "description": "The PEM data of the extra root certificates for workload-to-workload communication. This includes the certificates defined in MeshConfig and any other certificates that Istiod uses as CA. The plugin certificates (the 'cacerts' secret), self-signed certificates (the 'istio-ca-secret' secret) are added automatically by Istiod.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "privateKeyProvider": {
            "$ref": "#/components/schemas/istio.mesh.v1alpha1.PrivateKeyProvider"
          }
        },
        "oneOf": [
          {
            "not": {
              "anyOf": [
                {
                  "required": [
                    "serviceCluster"
                  ],
                  "properties": {
                    "serviceCluster": {
                      "description": "Service cluster defines the name for the `service_cluster` that is shared by all Envoy instances. This setting corresponds to `--service-cluster` flag in Envoy.  In a typical Envoy deployment, the `service-cluster` flag is used to identify the caller, for source-based routing scenarios. Since Istio does not assign a local `service/service` version to each Envoy instance, the name is same for all of them.  However, the source/caller's identity (e.g., IP address) is encoded in the `--service-node` flag when launching Envoy.  When the RDS service receives API calls from Envoy, it uses the value of the `service-node` flag to compute routes that are relative to the service instances located at that IP address.",
                      "type": "string"
                    }
                  }
                },
                {
                  "required": [
                    "tracingServiceName"
                  ],
                  "properties": {
                    "tracingServiceName": {
                      "$ref": "#/components/schemas/istio.mesh.v1alpha1.ProxyConfig.TracingServiceName"
                    }
                  }
                }
              ]
            }
          },
          {
            "required": [
              "serviceCluster"
            ],
            "properties": {
              "serviceCluster": {
                "description": "Service cluster defines the name for the `service_cluster` that is shared by all Envoy instances. This setting corresponds to `--service-cluster` flag in Envoy.  In a typical Envoy deployment, the `service-cluster` flag is used to identify the caller, for source-based routing scenarios. Since Istio does not assign a local `service/service` version to each Envoy instance, the name is same for all of them.  However, the source/caller's identity (e.g., IP address) is encoded in the `--service-node` flag when launching Envoy.  When the RDS service receives API calls from Envoy, it uses the value of the `service-node` flag to compute routes that are relative to the service instances located at that IP address.",
                "type": "string"
              }
            }
          },
          {
            "required": [
              "tracingServiceName"
            ],
            "properties": {
              "tracingServiceName": {
                "$ref": "#/components/schemas/istio.mesh.v1alpha1.ProxyConfig.TracingServiceName"
              }
            }
          }
        ]
      },
      "istio.mesh.v1alpha1.ProxyConfig.InboundInterceptionMode": {
        "description": "The mode used to redirect inbound traffic to Envoy. This setting has no effect on outbound traffic: iptables `REDIRECT` is always used for outbound connections.",
        "type": "string",
        "enum": [
          "REDIRECT",
          "TPROXY",
          "NONE"
        ]
      },
      "istio.mesh.v1alpha1.ProxyConfig.ProxyStatsMatcher": {
        "description": "Proxy stats name matchers for stats creation. Note this is in addition to the minimum Envoy stats that Istio generates by default.",
        "type": "object",
        "properties": {
          "inclusionPrefixes": {
            "description": "Proxy stats name prefix matcher for inclusion.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "inclusionSuffixes": {
            "description": "Proxy stats name suffix matcher for inclusion.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "inclusionRegexps": {
            "description": "Proxy stats name regexps matcher for inclusion.",
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "istio.mesh.v1alpha1.ProxyConfig.TracingServiceName": {
        "$ref": "#/components/schemas/istio.mesh.v1alpha1.ProxyConfig.TracingServiceName"
      },
      "istio.mesh.v1alpha1.RemoteService": {
        "type": "object",
        "properties": {
          "address": {
            "description": "Address of a remove service used for various purposes (access log receiver, metrics receiver, etc.). Can be IP address or a fully qualified DNS name.",
            "type": "string"
          },
          "tcpKeepalive": {
            "$ref": "#/components/schemas/istio.networking.v1alpha3.ConnectionPoolSettings.TCPSettings.TcpKeepalive"
          },
          "tlsSettings": {
            "$ref": "#/components/schemas/istio.networking.v1alpha3.ClientTLSSettings"
          }
        }
      },
      "istio.mesh.v1alpha1.Resource": {
        "description": "Resource describes the source of configuration",
        "type": "string",
        "enum": [
          "SERVICE_REGISTRY"
        ]
      },
      "istio.mesh.v1alpha1.SDS": {
        "description": "SDS defines secret discovery service(SDS) configuration to be used by the proxy. For workload, its values are set in sidecar injector(passed as arguments to istio-proxy container). For pilot/mixer, it's passed as arguments to istio-proxy container in pilot/mixer deployment yaml files directly. $hide_from_docs",
        "type": "object",
        "properties": {
          "enabled": {
            "description": "True if SDS is enabled.",
            "type": "boolean"
          },
          "k8sSaJwtPath": {
            "description": "Path of k8s service account JWT path.",
            "type": "string"
          }
        }
      },
      "istio.mesh.v1alpha1.Topology": {
        "type": "object",
        "properties": {
          "numTrustedProxies": {
            "type": "integer"
          },
          "forwardClientCertDetails": {
            "$ref": "#/components/schemas/istio.mesh.v1alpha1.Topology.ForwardClientCertDetails"
          }
        }
      },
      "istio.mesh.v1alpha1.Topology.ForwardClientCertDetails": {
        "type": "string",
        "enum": [
          "UNDEFINED",
          "SANITIZE",
          "FORWARD_ONLY",
          "APPEND_FORWARD",
          "SANITIZE_SET",
          "ALWAYS_FORWARD_ONLY"
        ]
      },
      "istio.mesh.v1alpha1.Tracing": {
        "description": "Tracing defines configuration for the tracing performed by Envoy instances.",
        "type": "object",
        "properties": {
          "tlsSettings": {
            "$ref": "#/components/schemas/istio.networking.v1alpha3.ClientTLSSettings"
          },
          "customTags": {
            "description": "Configures the custom tags to be added to active span by all proxies (i.e. sidecars and gateways). The key represents the name of the tag. Ex: ```yaml custom_tags: new_tag_name: header: name: custom-http-header-name default_value: defaulted-value-from-custom-header ``` $hide_from_docs",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/istio.mesh.v1alpha1.Tracing.CustomTag"
            }
          },
          "maxPathTagLength": {
            "description": "Configures the maximum length of the request path to extract and include in the HttpUrl tag. Used to truncate length request paths to meet the needs of tracing backend. If not set, then a length of 256 will be used. $hide_from_docs",
            "type": "integer"
          },
          "sampling": {
            "description": "The percentage of requests (0.0 - 100.0) that will be randomly selected for trace generation, if not requested by the client or not forced. Default is 1.0.",
            "type": "number",
            "format": "double"
          }
        },
        "oneOf": [
          {
            "not": {
              "anyOf": [
                {
                  "required": [
                    "zipkin"
                  ],
                  "properties": {
                    "zipkin": {
                      "$ref": "#/components/schemas/istio.mesh.v1alpha1.Tracing.Zipkin"
                    }
                  }
                },
                {
                  "required": [
                    "lightstep"
                  ],
                  "properties": {
                    "lightstep": {
                      "$ref": "#/components/schemas/istio.mesh.v1alpha1.Tracing.Lightstep"
                    }
                  }
                },
                {
                  "required": [
                    "datadog"
                  ],
                  "properties": {
                    "datadog": {
                      "$ref": "#/components/schemas/istio.mesh.v1alpha1.Tracing.Datadog"
                    }
                  }
                },
                {
                  "required": [
                    "stackdriver"
                  ],
                  "properties": {
                    "stackdriver": {
                      "$ref": "#/components/schemas/istio.mesh.v1alpha1.Tracing.Stackdriver"
                    }
                  }
                },
                {
                  "required": [
                    "openCensusAgent"
                  ],
                  "properties": {
                    "openCensusAgent": {
                      "$ref": "#/components/schemas/istio.mesh.v1alpha1.Tracing.OpenCensusAgent"
                    }
                  }
                }
              ]
            }
          },
          {
            "required": [
              "zipkin"
            ],
            "properties": {
              "zipkin": {
                "$ref": "#/components/schemas/istio.mesh.v1alpha1.Tracing.Zipkin"
              }
            }
          },
          {
            "required": [
              "lightstep"
            ],
            "properties": {
              "lightstep": {
                "$ref": "#/components/schemas/istio.mesh.v1alpha1.Tracing.Lightstep"
              }
            }
          },
          {
            "required": [
              "datadog"
            ],
            "properties": {
              "datadog": {
                "$ref": "#/components/schemas/istio.mesh.v1alpha1.Tracing.Datadog"
              }
            }
          },
          {
            "required": [
              "stackdriver"
            ],
            "properties": {
              "stackdriver": {
                "$ref": "#/components/schemas/istio.mesh.v1alpha1.Tracing.Stackdriver"
              }
            }
          },
          {
            "required": [
              "openCensusAgent"
            ],
            "properties": {
              "openCensusAgent": {
                "$ref": "#/components/schemas/istio.mesh.v1alpha1.Tracing.OpenCensusAgent"
              }
            }
          }
        ]
      },
      "istio.mesh.v1alpha1.Tracing.CustomTag": {
        "description": "Configure custom tags that will be added to any active span. Tags can be generated via literals, environment variables or an incoming request header. $hide_from_docs",
        "type": "object",
        "oneOf": [
          {
            "not": {
              "anyOf": [
                {
                  "required": [
                    "literal"
                  ],
                  "properties": {
                    "literal": {
                      "$ref": "#/components/schemas/istio.mesh.v1alpha1.Tracing.Literal"
                    }
                  }
                },
                {
                  "required": [
                    "environment"
                  ],
                  "properties": {
                    "environment": {
                      "$ref": "#/components/schemas/istio.mesh.v1alpha1.Tracing.Environment"
                    }
                  }
                },
                {
                  "required": [
                    "header"
                  ],
                  "properties": {
                    "header": {
                      "$ref": "#/components/schemas/istio.mesh.v1alpha1.Tracing.RequestHeader"
                    }
                  }
                }
              ]
            }
          },
          {
            "required": [
              "literal"
            ],
            "properties": {
              "literal": {
                "$ref": "#/components/schemas/istio.mesh.v1alpha1.Tracing.Literal"
              }
            }
          },
          {
            "required": [
              "environment"
            ],
            "properties": {
              "environment": {
                "$ref": "#/components/schemas/istio.mesh.v1alpha1.Tracing.Environment"
              }
            }
          },
          {
            "required": [
              "header"
            ],
            "properties": {
              "header": {
                "$ref": "#/components/schemas/istio.mesh.v1alpha1.Tracing.RequestHeader"
              }
            }
          }
        ]
      },
      "istio.mesh.v1alpha1.Tracing.Datadog": {
        "$ref": "#/components/schemas/istio.mesh.v1alpha1.Tracing.Datadog"
      },
      "istio.mesh.v1alpha1.Tracing.Environment": {
        "description": "Environment is the proxy's environment variable to be used for populating the custom span tag. $hide_from_docs",
        "type": "object",
        "properties": {
          "name": {
            "description": "Name of the environment variable used to populate the tag's value",
            "type": "string"
          },
          "defaultValue": {
            "description": "When the environment variable is not found, the tag's value will be populated with this default value if specified, otherwise the tag will not be populated.",
            "type": "string"
          }
        }
      },
      "istio.mesh.v1alpha1.Tracing.Lightstep": {
        "$ref": "#/components/schemas/istio.mesh.v1alpha1.Tracing.Lightstep"
      },
      "istio.mesh.v1alpha1.Tracing.Literal": {
        "description": "Literal type represents a static value. $hide_from_docs",
        "type": "object",
        "properties": {
          "value": {
            "description": "Static literal value used to populate the tag value.",
            "type": "string"
          }
        }
      },
      "istio.mesh.v1alpha1.Tracing.OpenCensusAgent": {
        "$ref": "#/components/schemas/istio.mesh.v1alpha1.Tracing.OpenCensusAgent"
      },
      "istio.mesh.v1alpha1.Tracing.RequestHeader": {
        "description": "RequestHeader is the HTTP request header which will be used to populate the span tag. A default value can be configured if the header does not exist. $hide_from_docs",
        "type": "object",
        "properties": {
          "name": {
            "description": "HTTP header name used to obtain the value from to populate the tag value.",
            "type": "string"
          },
          "defaultValue": {
            "description": "Default value to be used for the tag when the named HTTP header does not exist. The tag will be skipped if no default value is provided.",
            "type": "string"
          }
        }
      },
      "istio.mesh.v1alpha1.Tracing.Stackdriver": {
        "$ref": "#/components/schemas/istio.mesh.v1alpha1.Tracing.Stackdriver"
      },
      "istio.mesh.v1alpha1.Tracing.Zipkin": {
        "$ref": "#/components/schemas/istio.mesh.v1alpha1.Tracing.Zipkin"
      },
      "istio.networking.v1alpha3.ClientTLSSettings": {
        "description": "SSL/TLS related settings for upstream connections. See Envoy's [TLS context](https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/transport_sockets/tls/v3/common.proto.html#common-tls-configuration) for more details. These settings are common to both HTTP and TCP upstreams. For example, the following rule configures a client to use mutual TLS for connections to upstream database cluster. {{\u003ctabset category-name=\"example\"\u003e}} {{\u003ctab name=\"v1alpha3\" category-value=\"v1alpha3\"\u003e}} ```yaml apiVersion: networking.istio.io/v1alpha3 kind: DestinationRule metadata: name: db-mtls spec: host: mydbserver.prod.svc.cluster.local trafficPolicy: tls: mode: MUTUAL clientCertificate: /etc/certs/myclientcert.pem privateKey: /etc/certs/client_private_key.pem caCertificates: /etc/certs/rootcacerts.pem ``` {{\u003c/tab\u003e}} {{\u003ctab name=\"v1beta1\" category-value=\"v1beta1\"\u003e}} ```yaml apiVersion: networking.istio.io/v1beta1 kind: DestinationRule metadata: name: db-mtls spec: host: mydbserver.prod.svc.cluster.local trafficPolicy: tls: mode: MUTUAL clientCertificate: /etc/certs/myclientcert.pem privateKey: /etc/certs/client_private_key.pem caCertificates: /etc/certs/rootcacerts.pem ``` {{\u003c/tab\u003e}} {{\u003c/tabset\u003e}} The following rule configures a client to use TLS when talking to a foreign service whose domain matches *.foo.com. {{\u003ctabset category-name=\"example\"\u003e}} {{\u003ctab name=\"v1alpha3\" category-value=\"v1alpha3\"\u003e}} ```yaml apiVersion: networking.istio.io/v1alpha3 kind: DestinationRule metadata: name: tls-foo spec: host: \"*.foo.com\" trafficPolicy: tls: mode: SIMPLE ``` {{\u003c/tab\u003e}} {{\u003ctab name=\"v1beta1\" category-value=\"v1beta1\"\u003e}} ```yaml apiVersion: networking.istio.io/v1beta1 kind: DestinationRule metadata: name: tls-foo spec: host: \"*.foo.com\" trafficPolicy: tls: mode: SIMPLE ``` {{\u003c/tab\u003e}} {{\u003c/tabset\u003e}} The following rule configures a client to use Istio mutual TLS when talking to rating services. {{\u003ctabset category-name=\"example\"\u003e}} {{\u003ctab name=\"v1alpha3\" category-value=\"v1alpha3\"\u003e}} ```yaml apiVersion: networking.istio.io/v1alpha3 kind: DestinationRule metadata: name: ratings-istio-mtls spec: host: ratings.prod.svc.cluster.local trafficPolicy: tls: mode: ISTIO_MUTUAL ``` {{\u003c/tab\u003e}} {{\u003ctab name=\"v1beta1\" category-value=\"v1beta1\"\u003e}} ```yaml apiVersion: networking.istio.io/v1beta1 kind: DestinationRule metadata: name: ratings-istio-mtls spec: host: ratings.prod.svc.cluster.local trafficPolicy: tls: mode: ISTIO_MUTUAL ``` {{\u003c/tab\u003e}} {{\u003c/tabset\u003e}}",
        "type": "object",
        "properties": {
          "mode": {
            "$ref": "#/components/schemas/istio.networking.v1alpha3.ClientTLSSettings.TLSmode"
          },
          "clientCertificate": {
            "description": "REQUIRED if mode is `MUTUAL`. The path to the file holding the client-side TLS certificate to use. Should be empty if mode is `ISTIO_MUTUAL`.",
            "type": "string"
          },
          "privateKey": {
            "description": "REQUIRED if mode is `MUTUAL`. The path to the file holding the client's private key. Should be empty if mode is `ISTIO_MUTUAL`.",
            "type": "string"
          },
          "caCertificates": {
            "description": "OPTIONAL: The path to the file containing certificate authority certificates to use in verifying a presented server certificate. If omitted, the proxy will not verify the server's certificate. Should be empty if mode is `ISTIO_MUTUAL`.",
            "type": "string"
          },
          "credentialName": {
            "description": "The name of the secret that holds the TLS certs for the client including the CA certificates. Secret must exist in the same namespace with the proxy using the certificates. The secret (of type `generic`)should contain the following keys and values: `key: \u003cprivateKey\u003e`, `cert: \u003cclientCert\u003e`, `cacert: \u003cCACertificate\u003e`. Here CACertificate is used to verify the server certificate. For mutual TLS, `cacert: \u003cCACertificate\u003e` can be provided in the same secret or a separate secret named `\u003csecret\u003e-cacert`. Secret of type tls for client certificates along with ca.crt key for CA certificates is also supported. Only one of client certificates and CA certificate or credentialName can be specified. **NOTE:** This field is applicable at sidecars only if `DestinationRule` has a `workloadSelector` specified. Otherwise the field will be applicable only at gateways, and sidecars will continue to use the certificate paths.",
            "type": "string"
          },
          "subjectAltNames": {
            "description": "A list of alternate names to verify the subject identity in the certificate. If specified, the proxy will verify that the server certificate's subject alt name matches one of the specified values. If specified, this list overrides the value of subject_alt_names from the ServiceEntry. If unspecified, automatic validation of upstream presented certificate for new upstream connections will be done based on the downstream HTTP host/authority header, provided `VERIFY_CERTIFICATE_AT_CLIENT` and `ENABLE_AUTO_SNI` environmental variables are set to `true`.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "sni": {
            "description": "SNI string to present to the server during TLS handshake. If unspecified, SNI will be automatically set based on downstream HTTP host/authority header for SIMPLE and MUTUAL TLS modes, provided `ENABLE_AUTO_SNI` environmental variable is set to `true`.",
            "type": "string"
          },
          "insecureSkipVerify": {
            "description": "InsecureSkipVerify specifies whether the proxy should skip verifying the CA signature and SAN for the server certificate corresponding to the host. This flag should only be set if global CA signature verifcation is enabled, `VerifyCertAtClient` environmental variable is set to `true`, but no verification is desired for a specific host. If enabled with or without `VerifyCertAtClient` enabled, verification of the CA signature and SAN will be skipped. `InsecureSkipVerify` is `false` by default. `VerifyCertAtClient` is `false` by default in Istio version 1.9 but will be `true` by default in a later version where, going forward, it will be enabled by default.",
            "type": "boolean",
            "nullable": true
          }
        }
      },
      "istio.networking.v1alpha3.ClientTLSSettings.TLSmode": {
        "description": "TLS connection mode",
        "type": "string",
        "enum": [
          "DISABLE",
          "SIMPLE",
          "MUTUAL",
          "ISTIO_MUTUAL"
        ]
      },
      "istio.networking.v1alpha3.ConnectionPoolSettings.TCPSettings.TcpKeepalive": {
        "description": "TCP keepalive.",
        "type": "object",
        "properties": {
          "time": {
            "description": "The time duration a connection needs to be idle before keep-alive probes start being sent. Default is to use the OS level configuration (unless overridden, Linux defaults to 7200s (ie 2 hours.)",
            "type": "string"
          },
          "probes": {
            "description": "Maximum number of keepalive probes to send without response before deciding the connection is dead. Default is to use the OS level configuration (unless overridden, Linux defaults to 9.)",
            "type": "integer"
          },
          "interval": {
            "description": "The time duration between keep-alive probes. Default is to use the OS level configuration (unless overridden, Linux defaults to 75s.)",
            "type": "string"
          }
        }
      },
      "istio.networking.v1alpha3.ExecHealthCheckConfig": {
        "type": "object",
        "properties": {
          "command": {
            "description": "Command to run. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.",
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "istio.networking.v1alpha3.HTTPHeader": {
        "type": "object",
        "properties": {
          "name": {
            "description": "The header field name",
            "type": "string"
          },
          "value": {
            "description": "The header field value",
            "type": "string"
          }
        }
      },
      "istio.networking.v1alpha3.HTTPHealthCheckConfig": {
        "type": "object",
        "properties": {
          "path": {
            "description": "Path to access on the HTTP server.",
            "type": "string"
          },
          "port": {
            "description": "Port on which the endpoint lives.",
            "type": "integer"
          },
          "host": {
            "description": "Host name to connect to, defaults to the pod IP. You probably want to set \"Host\" in httpHeaders instead.",
            "type": "string"
          },
          "scheme": {
            "description": "HTTP or HTTPS, defaults to HTTP",
            "type": "string"
          },
          "httpHeaders": {
            "description": "Headers the proxy will pass on to make the request. Allows repeated headers.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/istio.networking.v1alpha3.HTTPHeader"
            }
          }
        }
      },
      "istio.networking.v1alpha3.HTTPRetry": {
        "description": "Describes the retry policy to use when a HTTP request fails. For example, the following rule sets the maximum number of retries to 3 when calling ratings:v1 service, with a 2s timeout per retry attempt. A retry will be attempted if there is a connect-failure, refused_stream or when the upstream server responds with Service Unavailable(503). {{\u003ctabset category-name=\"example\"\u003e}} {{\u003ctab name=\"v1alpha3\" category-value=\"v1alpha3\"\u003e}} ```yaml apiVersion: networking.istio.io/v1alpha3 kind: VirtualService metadata: name: ratings-route spec: hosts: - ratings.prod.svc.cluster.local http: - route: - destination: host: ratings.prod.svc.cluster.local subset: v1 retries: attempts: 3 perTryTimeout: 2s retryOn: connect-failure,refused-stream,503 ``` {{\u003c/tab\u003e}} {{\u003ctab name=\"v1beta1\" category-value=\"v1beta1\"\u003e}} ```yaml apiVersion: networking.istio.io/v1beta1 kind: VirtualService metadata: name: ratings-route spec: hosts: - ratings.prod.svc.cluster.local http: - route: - destination: host: ratings.prod.svc.cluster.local subset: v1 retries: attempts: 3 perTryTimeout: 2s retryOn: gateway-error,connect-failure,refused-stream ``` {{\u003c/tab\u003e}} {{\u003c/tabset\u003e}}",
        "type": "object",
        "properties": {
          "attempts": {
            "description": "Number of retries to be allowed for a given request. The interval between retries will be determined automatically (25ms+). When request `timeout` of the [HTTP route](https://istio.io/docs/reference/config/networking/virtual-service/#HTTPRoute) or `per_try_timeout` is configured, the actual number of retries attempted also depends on the specified request `timeout` and `per_try_timeout` values.",
            "type": "integer",
            "format": "int32"
          },
          "perTryTimeout": {
            "description": "Timeout per attempt for a given request, including the initial call and any retries. Format: 1h/1m/1s/1ms. MUST BE \u003e=1ms. Default is same value as request `timeout` of the [HTTP route](https://istio.io/docs/reference/config/networking/virtual-service/#HTTPRoute), which means no timeout.",
            "type": "string"
          },
          "retryOn": {
            "description": "Specifies the conditions under which retry takes place. One or more policies can be specified using a ‘,’ delimited list. If `retry_on` specifies a valid HTTP status, it will be added to retriable_status_codes retry policy. See the [retry policies](https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#x-envoy-retry-on) and [gRPC retry policies](https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#x-envoy-retry-grpc-on) for more details.",
            "type": "string"
          },
          "retryRemoteLocalities": {
            "description": "Flag to specify whether the retries should retry to other localities. See the [retry plugin configuration](https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/http/http_connection_management#retry-plugin-configuration) for more details.",
            "type": "boolean",
            "nullable": true
          }
        }
      },
      "istio.networking.v1alpha3.LocalityLoadBalancerSetting": {
        "description": "Locality-weighted load balancing allows administrators to control the distribution of traffic to endpoints based on the localities of where the traffic originates and where it will terminate. These localities are specified using arbitrary labels that designate a hierarchy of localities in {region}/{zone}/{sub-zone} form. For additional detail refer to [Locality Weight](https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/upstream/load_balancing/locality_weight) The following example shows how to setup locality weights mesh-wide. Given a mesh with workloads and their service deployed to \"us-west/zone1/*\" and \"us-west/zone2/*\". This example specifies that when traffic accessing a service originates from workloads in \"us-west/zone1/*\", 80% of the traffic will be sent to endpoints in \"us-west/zone1/*\", i.e the same zone, and the remaining 20% will go to endpoints in \"us-west/zone2/*\". This setup is intended to favor routing traffic to endpoints in the same locality. A similar setting is specified for traffic originating in \"us-west/zone2/*\". ```yaml distribute: - from: us-west/zone1/* to: \"us-west/zone1/*\": 80 \"us-west/zone2/*\": 20 - from: us-west/zone2/* to: \"us-west/zone1/*\": 20 \"us-west/zone2/*\": 80 ``` If the goal of the operator is not to distribute load across zones and regions but rather to restrict the regionality of failover to meet other operational requirements an operator can set a 'failover' policy instead of a 'distribute' policy. The following example sets up a locality failover policy for regions. Assume a service resides in zones within us-east, us-west \u0026 eu-west this example specifies that when endpoints within us-east become unhealthy traffic should failover to endpoints in any zone or sub-zone within eu-west and similarly us-west should failover to us-east. ```yaml failover: - from: us-east to: eu-west - from: us-west to: us-east ``` Locality load balancing settings.",
        "type": "object",
        "properties": {
          "distribute": {
            "description": "Optional: only one of distribute, failover or failoverPriority can be set. Explicitly specify loadbalancing weight across different zones and geographical locations. Refer to [Locality weighted load balancing](https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/upstream/load_balancing/locality_weight) If empty, the locality weight is set according to the endpoints number within it.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/istio.networking.v1alpha3.LocalityLoadBalancerSetting.Distribute"
            }
          },
          "failover": {
            "description": "Optional: only one of distribute, failover or failoverPriority can be set. Explicitly specify the region traffic will land on when endpoints in local region becomes unhealthy. Should be used together with OutlierDetection to detect unhealthy endpoints. Note: if no OutlierDetection specified, this will not take effect.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/istio.networking.v1alpha3.LocalityLoadBalancerSetting.Failover"
            }
          },
          "failoverPriority": {
            "description": "failoverPriority is an ordered list of labels used to sort endpoints to do priority based load balancing. This is to support traffic failover across different groups of endpoints. Suppose there are total N labels specified: 1. Endpoints matching all N labels with the client proxy have priority P(0) i.e. the highest priority. 2. Endpoints matching the first N-1 labels with the client proxy have priority P(1) i.e. second highest priority. 3. By extension of this logic, endpoints matching only the first label with the client proxy has priority P(N-1) i.e. second lowest priority. 4. All the other endpoints have priority P(N) i.e. lowest priority. Note: For a label to be considered for match, the previous labels must match, i.e. nth label would be considered matched only if first n-1 labels match. It can be any label specified on both client and server workloads. The following labels which have special semantic meaning are also supported: - `topology.istio.io/network` is used to match the network metadata of an endpoint, which can be specified by pod/namespace label `topology.istio.io/network`, sidecar env `ISTIO_META_NETWORK` or MeshNetworks. - `topology.istio.io/cluster` is used to match the clusterID of an endpoint, which can be specified by pod label `topology.istio.io/cluster` or pod env `ISTIO_META_CLUSTER_ID`. - `topology.kubernetes.io/region` is used to match the region metadata of an endpoint, which maps to Kubernetes node label `topology.kubernetes.io/region` or the deprecated label `failure-domain.beta.kubernetes.io/region`. - `topology.kubernetes.io/zone` is used to match the zone metadata of an endpoint, which maps to Kubernetes node label `topology.kubernetes.io/zone` or the deprecated label `failure-domain.beta.kubernetes.io/zone`. - `topology.istio.io/subzone` is used to match the subzone metadata of an endpoint, which maps to Istio node label `topology.istio.io/subzone`. The below topology config indicates the following priority levels: ```yaml failoverPriority: - \"topology.istio.io/network\" - \"topology.kubernetes.io/region\" - \"topology.kubernetes.io/zone\" - \"topology.istio.io/subzone\" ``` 1. endpoints match same [network, region, zone, subzone] label with the client proxy have the highest priority. 2. endpoints have same [network, region, zone] label but different [subzone] label with the client proxy have the second highest priority. 3. endpoints have same [network, region] label but different [zone] label with the client proxy have the third highest priority. 4. endpoints have same [network] but different [region] labels with the client proxy have the fourth highest priority. 5. all the other endpoints have the same lowest priority. Optional: only one of distribute, failover or failoverPriority can be set. And it should be used together with `OutlierDetection` to detect unhealthy endpoints, otherwise has no effect.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "enabled": {
            "description": "enable locality load balancing, this is DestinationRule-level and will override mesh wide settings in entirety. e.g. true means that turn on locality load balancing for this DestinationRule no matter what mesh wide settings is.",
            "type": "boolean",
            "nullable": true
          }
        }
      },
      "istio.networking.v1alpha3.LocalityLoadBalancerSetting.Distribute": {
        "description": "Describes how traffic originating in the 'from' zone or sub-zone is distributed over a set of 'to' zones. Syntax for specifying a zone is {region}/{zone}/{sub-zone} and terminal wildcards are allowed on any segment of the specification. Examples: `*` - matches all localities `us-west/*` - all zones and sub-zones within the us-west region `us-west/zone-1/*` - all sub-zones within us-west/zone-1",
        "type": "object",
        "properties": {
          "from": {
            "description": "Originating locality, '/' separated, e.g. 'region/zone/sub_zone'.",
            "type": "string"
          },
          "to": {
            "description": "Map of upstream localities to traffic distribution weights. The sum of all weights should be 100. Any locality not present will receive no traffic.",
            "type": "object",
            "additionalProperties": {
              "type": "integer"
            }
          }
        }
      },
      "istio.networking.v1alpha3.LocalityLoadBalancerSetting.Failover": {
        "description": "Specify the traffic failover policy across regions. Since zone and sub-zone failover is supported by default this only needs to be specified for regions when the operator needs to constrain traffic failover so that the default behavior of failing over to any endpoint globally does not apply. This is useful when failing over traffic across regions would not improve service health or may need to be restricted for other reasons like regulatory controls.",
        "type": "object",
        "properties": {
          "from": {
            "description": "Originating region.",
            "type": "string"
          },
          "to": {
            "description": "Destination region the traffic will fail over to when endpoints in the 'from' region becomes unhealthy.",
            "type": "string"
          }
        }
      },
      "istio.networking.v1alpha3.ReadinessProbe": {
        "type": "object",
        "properties": {
          "timeoutSeconds": {
            "description": "Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1 second.",
            "type": "integer",
            "format": "int32"
          },
          "initialDelaySeconds": {
            "description": "Number of seconds after the container has started before readiness probes are initiated.",
            "type": "integer",
            "format": "int32"
          },
          "periodSeconds": {
            "description": "How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1 second.",
            "type": "integer",
            "format": "int32"
          },
          "successThreshold": {
            "description": "Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1 second.",
            "type": "integer",
            "format": "int32"
          },
          "failureThreshold": {
            "description": "Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3 seconds.",
            "type": "integer",
            "format": "int32"
          }
        },
        "oneOf": [
          {
            "not": {
              "anyOf": [
                {
                  "required": [
                    "httpGet"
                  ],
                  "properties": {
                    "httpGet": {
                      "$ref": "#/components/schemas/istio.networking.v1alpha3.HTTPHealthCheckConfig"
                    }
                  }
                },
                {
                  "required": [
                    "tcpSocket"
                  ],
                  "properties": {
                    "tcpSocket": {
                      "$ref": "#/components/schemas/istio.networking.v1alpha3.TCPHealthCheckConfig"
                    }
                  }
                },
                {
                  "required": [
                    "exec"
                  ],
                  "properties": {
                    "exec": {
                      "$ref": "#/components/schemas/istio.networking.v1alpha3.ExecHealthCheckConfig"
                    }
                  }
                }
              ]
            }
          },
          {
            "required": [
              "httpGet"
            ],
            "properties": {
              "httpGet": {
                "$ref": "#/components/schemas/istio.networking.v1alpha3.HTTPHealthCheckConfig"
              }
            }
          },
          {
            "required": [
              "tcpSocket"
            ],
            "properties": {
              "tcpSocket": {
                "$ref": "#/components/schemas/istio.networking.v1alpha3.TCPHealthCheckConfig"
              }
            }
          },
          {
            "required": [
              "exec"
            ],
            "properties": {
              "exec": {
                "$ref": "#/components/schemas/istio.networking.v1alpha3.ExecHealthCheckConfig"
              }
            }
          }
        ]
      },
      "istio.networking.v1alpha3.TCPHealthCheckConfig": {
        "type": "object",
        "properties": {
          "port": {
            "description": "Port of host",
            "type": "integer"
          },
          "host": {
            "description": "Host to connect to, defaults to localhost",
            "type": "string"
          }
        }
      },
      "istio.networking.v1beta1.ProxyImage": {
        "description": "The following values are used to construct proxy image url. format: `${hub}/${image_name}/${tag}-${image_type}`, example: `docker.io/istio/proxyv2:1.11.1` or `docker.io/istio/proxyv2:1.11.1-distroless`. This information was previously part of the Values API.",
        "type": "object",
        "properties": {
          "imageType": {
            "description": "The image type of the image. Istio publishes default, debug, and distroless images. Other values are allowed if those image types (example: centos) are published to the specified hub. supported values: default, debug, distroless.",
            "type": "string"
          }
        }
      },
      "istio_operator.v2.api.v1alpha1.ConfigState": {
        "type": "string",
        "enum": [
          "Unspecified",
          "Created",
          "ReconcileFailed",
          "Reconciling",
          "Available",
          "Unmanaged"
        ]
      },
      "istio_operator.v2.api.v1alpha1.IstioMeshSpec": {
        "description": "Mesh defines an Istio service mesh",
        "type": "object",
        "properties": {
          "config": {
            "$ref": "#/components/schemas/istio.mesh.v1alpha1.MeshConfig"
          }
        }
      },
      "istio_operator.v2.api.v1alpha1.IstioMeshStatus": {
        "type": "object",
        "properties": {
          "status": {
            "$ref": "#/components/schemas/istio_operator.v2.api.v1alpha1.ConfigState"
          },
          "errorMessage": {
            "description": "Reconciliation error message if any",
            "type": "string"
          }
        }
      },
      "k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector": {
        "description": "A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.",
        "type": "object",
        "properties": {
          "matchLabels": {
            "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
            "type": "object",
            "additionalProperties": {
              "type": "string"
            }
          },
          "matchExpressions": {
            "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelectorRequirement"
            }
          }
        }
      },
      "k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelectorRequirement": {
        "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
        "type": "object",
        "properties": {
          "key": {
            "description": "key is the label key that the selector applies to.",
            "type": "string"
          },
          "operator": {
            "description": "operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.",
            "type": "string"
          },
          "values": {
            "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      }
    }
  }
}